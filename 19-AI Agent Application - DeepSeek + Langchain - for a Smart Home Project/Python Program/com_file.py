# -*- coding: utf-8 -*-
"""Copie de Copie de Simulation_LLM_Agent_Controller_v2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12yi-HlZnnGXxue-aJNrXa3Z8UmW6ezH1
"""

#Langchain tools:
from langchain_core.prompts import ChatPromptTemplate
from langchain_groq import ChatGroq
from langchain.chains.conversation.memory import ConversationBufferWindowMemory
from langchain.agents import Tool
from langchain.tools import BaseTool

#LLM model declaration and i choosed Llama3 70b parameters:
llm = ChatGroq(temperature=0, groq_api_key="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", model_name="deepseek-r1-distill-llama-70b")

"""# L'environement de Simulation and de test:"""

stats = [0,0,0]
stats_str = ["off","on","bliking"]

#Three tools for tuning on the lights in rooms:
import RPi.GPIO as GPIO
import time

# Configuration de la bibliotheque GPIO
GPIO.setmode(GPIO.BCM)  # Utilisation de la numerotation BCM
GPIO.setwarnings(False)  # Desactiver les avertissements

GPIO.setup(21, GPIO.OUT)
GPIO.setup(20, GPIO.OUT)
GPIO.setup(16, GPIO.OUT)
GPIO.output(16, GPIO.LOW)
GPIO.output(20, GPIO.LOW)
GPIO.output(21, GPIO.LOW)



def Turn_on_1(input=""):
    stats[0] = 1
    pin = 21
    GPIO.setup(pin, GPIO.OUT)
    GPIO.output(pin, GPIO.HIGH)
    return f'I turned {stats_str[stats[0]]} The light in Room 1'

on_light_tool1 = Tool(
    name='Turn on the lighting in room number 01',
    func= Turn_on_1,
    description="Useful only when you're asked about turning on the light in room number One."
)


def Turn_on_2(input=""):
    stats[1] = 1
    pin = 20
    GPIO.setup(pin, GPIO.OUT)
    GPIO.output(pin, GPIO.HIGH)
    return f'I turned {stats_str[stats[1]]} The light in Room 2'

on_light_tool2 = Tool(
    name='Turn on the lighting in room number 02',
    func= Turn_on_2,
    description="Useful only when you're asked about turning on the light in room number Two."
)


def Turn_on_3(input=""):
    stats[2] = 1
    pin = 16
    GPIO.setup(pin, GPIO.OUT)
    GPIO.output(pin, GPIO.HIGH)
    return f'I turned {stats_str[stats[2]]} The light in Room 3'

on_light_tool3 = Tool(
    name='Turn on the lighting in room number 03',
    func= Turn_on_3,
    description="Useful only when you're asked about turning on the light in room number three."
)

#Tools for turning off the lights in the rooms
def Turn_off_1(input=""):
    stats[0] = 0
    pin = 21
    GPIO.setup(pin, GPIO.OUT)
    GPIO.output(pin, GPIO.LOW)
    return f'I turned {stats_str[stats[0]]} The light in Room 1'

off_light_tool1 = Tool(
    name='Turn off the lighting in room number 01',
    func= Turn_off_1,
    description="Useful only when you're asked about turning off the light in room number One."
)


def Turn_off_2(input=""):
    stats[1] = 0
    pin = 20
    GPIO.setup(pin, GPIO.OUT)
    GPIO.output(pin, GPIO.LOW)
    return f'I turned {stats_str[stats[1]]} The light in Room 2'

off_light_tool2 = Tool(
    name='Turn off the lighting in room number 02',
    func= Turn_off_2,
    description="Useful only when you're asked about turning off the light in room number Two."
)


def Turn_off_3(input=""):
    stats[2] = 0
    pin = 16
    GPIO.setup(pin, GPIO.OUT)
    GPIO.output(pin, GPIO.LOW)
    return f'I turned {stats_str[stats[2]]} The light in Room 3'

off_light_tool3 = Tool(
    name='Turn off the lighting in room number 03',
    func= Turn_off_3,
    description="Useful only when you're asked about turning off the light in room number three."
)

#Tool for asking of the states of lights in rooms
import random

def Light_states(input=""):
    # Creating multiple ways to rephrase the states
    light_phrases = [
        f"The light in room 1 is {stats_str[stats[0]]}, room 2 is {stats_str[stats[1]]}, and room 3 is {stats_str[stats[2]]}.",
        f"Rooms 1, 2, and 3 have lights that are {stats_str[stats[0]]}, {stats_str[stats[1]]}, and {stats_str[stats[2]]} respectively.",
        f"The light in room 1 is {stats_str[stats[0]]}, the light in room 2 is {stats_str[stats[1]]}, and the light in room 3 is {stats_str[stats[2]]}.",
        f"Room 1 has {stats_str[stats[0]]} light, room 2 has {stats_str[stats[1]]}light, and room 3 has {stats_str[stats[2]]}light."
    ]

    # Randomly shuffle or select a different phrasing each time
    random.shuffle(light_phrases)
    light_status = light_phrases[0]


    return f"{light_status}"


light_states = Tool(
    name='Asking for the states of the lights',
    func= Light_states,
    description="Useful only when you want to know the stats of the lights"
)




from multiprocessing import Process, Value
import time
import RPi.GPIO as GPIO

# Initialize GPIO settings
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)

# Create a shared flag for stopping the process
stop_flag = Value('b', True)

def Led1_fr(stop_flag, frequency):
    """Function to control LED blinking at a specific frequency."""
    while not stop_flag.value:
        GPIO.output(21, GPIO.HIGH)  # Turn LED on
        time.sleep(0.5 / frequency)
        GPIO.output(21, GPIO.LOW)   # Turn LED off
        time.sleep(0.5 / frequency)
    

# Global process variable
process1 = None
process2 = None
process3 = None

def Led1_frequency(frequency):
    """Start the LED with a specified frequency."""
    global process1
    if  stop_flag.value:  # Check if the LED is not already blinking
        stats[0] = 2
        stop_flag.value = False
        process1 = Process(target=Led1_fr, args=(stop_flag, float(frequency)))
        process1.start()
        return f"the light in room one is blinking at {frequency} Hz."
    else:
        return f"the light in room one is already blinking you need to stop it and start it again."

def stop_led1(input=""):
    """Stop the LED from blinking."""
    global process1
    stats[0] = 0
    if stop_flag.value:  # Check if the LED is already stopped
        return "the blinking ligh in room one is already stopped."
    else:
        stop_flag.value = True
        process1.join()  # Wait for the process to terminate
        return "the blinking ligh in room one  has been stopped."

Led1_fr_tool = Tool(
    name='Blinking Led 1',
    func= Led1_frequency,
    description="Useful only when you want to blink the light in only room one with a frequency"
)
Led1_fr_stop_tool = Tool(
    name='stop Blinking Led 1',
    func= stop_led1,
    description="Useful only when you want to sotp the blinkinhg of only light in room one"
)





stop_flag_ = Value('b', True)
def Led2_fr(stop_flag_, frequency):
    """Function to control LED blinking at a specific frequency."""
    while not stop_flag_.value:
        GPIO.output(20, GPIO.HIGH)  # Turn LED on
        time.sleep(0.5 / frequency)
        GPIO.output(20, GPIO.LOW)   # Turn LED off
        time.sleep(0.5 / frequency)

def Led2_frequency(frequency):
    """Start the LED with a specified frequency."""
    global process2
    if stop_flag_.value:  # Check if the LED is not already blinking
        stats[1] = 2
        stop_flag_.value = False
        process2 = Process(target=Led2_fr, args=(stop_flag_, float(frequency)))
        process2.start()
        return f"the light in room two is blinking at {frequency} Hz."
    else:
        return f"the light in room two is already blinking you need to stop it and start it again."

def stop_led2(input=""):
    """Stop the LED from blinking."""
    global process2
    stats[1] = 0
    if stop_flag_.value:  # Check if the LED is already stopped
        return "the blinking light in room two is already stopped."
    else:
        stop_flag_.value = True
        process2.join()  # Wait for the process to terminate
        return "the blinking light in room two has been stopped."

Led2_fr_tool = Tool(
    name='Blinking Led 2',
    func= Led2_frequency,
    description="Useful only when you want to blink the light in only room two with a frequency"
)
Led2_fr_stop_tool = Tool(
    name='stop Blinking Led 2',
    func= stop_led2,
    description="Useful only when you want to stop the blinkinhg light in light of room 2  only."
)









stop_flag__ = Value('b', True)
def Led3_fr(stop_flag__, frequency):
    """Function to control LED blinking at a specific frequency."""
    while not stop_flag__.value:
        GPIO.output(16, GPIO.HIGH)  # Turn LED on
        time.sleep(0.5 / frequency)
        GPIO.output(16, GPIO.LOW)   # Turn LED off
        time.sleep(0.5 / frequency)



def Led3_frequency(frequency):
    """Start the LED with a specified frequency."""
    global process3
    if stop_flag__.value:  # Check if the LED is not already blinking
        stats[2] = 2
        stop_flag__.value = False
        process3 = Process(target=Led3_fr, args=(stop_flag__, float(frequency)))
        process3.start()
        return f"LED 3 is blinking at {frequency} Hz."
    else:
        return f"the light in room three is already blinking you need to stop it and start it again."

def stop_led3(input=""):
    """Stop the LED from blinking."""
    global process3
    stats[2] = 0
    if stop_flag__.value:  # Check if the LED is already stopped
        return "the blinking light in room three is already stopped."
    else:
        stop_flag__.value = True
        process3.join()  # Wait for the process to terminate
        return "the blinking light in room three has been stopped."

Led3_fr_tool = Tool(
    name='Blinking Led 3',
    func= Led3_frequency,
    description="Useful only when you want to blink the light only in room 3 with a frequency"
)

Led3_fr_stop_tool = Tool(
    name='stop Blinking Led 3',
    func= stop_led3,
    description="Useful only when you want to stop the blinkinhg light in only room 3."
)















#Tool for searching information in Wikipedia
from langchain_community.retrievers import WikipediaRetriever
wikipedia_retriever = WikipediaRetriever()

# Define the new tool
search_tool = Tool(
    name="wikipedia_search",
    func=wikipedia_retriever.run,
    description="useful for when you need to answer questions based on Wikipedia articles"
)

#Tools for asking for the time
import requests
from datetime import datetime

def get_coordinates(city):
    # Open-Meteo geocoding API to get latitude and longitude for the city
    geocode_url = f"https://geocoding-api.open-meteo.com/v1/search?name={city}&count=1&language=en"
    geocode_response = requests.get(geocode_url)

    if geocode_response.status_code == 200:
        geocode_data = geocode_response.json()
        if geocode_data['results']:
            latitude = geocode_data['results'][0]['latitude']
            longitude = geocode_data['results'][0]['longitude']
            return latitude, longitude
        else:
            return None, None
    else:
        return None, None

def get_time(city):
    latitude, longitude = get_coordinates(city)

    if latitude is None or longitude is None:
        return f"Could not find coordinates for {city}."

    # Get time data using Open-Meteo and WorldTimeAPI
    time_url = f"http://worldtimeapi.org/api/timezone/Etc/GMT{int(longitude / 15)}.json"  # Simple GMT calculation
    time_response = requests.get(time_url)

    if time_response.status_code == 200:
        time_data = time_response.json()
        time = time_data['datetime']
        time = datetime.fromisoformat(time).strftime('%Y-%m-%d %H:%M:%S')
        return f"Local time in {city}: {time}"
    else:
        return f"Could not get the time data for {city}."

Time_tool = Tool(
    name='Asking for time',
    func= get_time,
    description="Useful only when you want to know the current time of a city in the world"
)

#Tool for requesting for the weather in a city in the world
import requests

def get_weather(city):
    latitude, longitude = get_coordinates(city)

    if latitude is None or longitude is None:
        return f"Could not find coordinates for {city}."

    # Get weather data using Open-Meteo
    weather_url = f"https://api.open-meteo.com/v1/forecast?latitude={latitude}&longitude={longitude}&current_weather=true"
    weather_response = requests.get(weather_url)

    if weather_response.status_code == 200:
        weather_data = weather_response.json()

        """temperature = weather_data['current_weather']['temperature']
        humidity = weather_data['current_weather']['humidity']
        wind_speed = weather_data['current_weather']['windspeed']
        wind_direction = weather_data['current_weather']['winddirection']
        pressure = weather_data['current_weather']['pressure']
        weather_description = weather_data['current_weather']['weathercode']"""

        # Providing additional weather information
        return (weather_data)
    else:
        return f"Could not get the weather data for {city}."


# Updated Weather_tool with more information
Weather_tool = Tool(
    name='Asking for Weather',
    func=get_weather,
    description="Useful for getting detailed weather data of a city worldwide"
)

import RPi.GPIO as GPIO
import time
from multiprocessing import Process, Value

stop_flagM = Value("b",True)

# GPIO Configuration
GPIO.setmode(GPIO.BCM)  # Use BCM pin numbering
GPIO.setup(2, GPIO.OUT)  # Orange
GPIO.setup(3, GPIO.OUT)  # Pink
GPIO.setup(4, GPIO.OUT)  # Yellow
GPIO.setup(5, GPIO.OUT)  # Blue

# Function to set a motor step
def set_step(w1, w2, w3, w4):
    GPIO.output(2, w1)  # Orange
    GPIO.output(3, w2)  # Pink
    GPIO.output(4, w3)  # Yellow
    GPIO.output(5, w4)  # Blue

# Sequence to turn the motor clockwise
step_sequence = [
    (GPIO.LOW, GPIO.HIGH, GPIO.HIGH, GPIO.HIGH),
    (GPIO.HIGH, GPIO.HIGH, GPIO.LOW, GPIO.HIGH),
    (GPIO.HIGH, GPIO.LOW, GPIO.HIGH, GPIO.HIGH),
    (GPIO.HIGH, GPIO.HIGH, GPIO.HIGH, GPIO.LOW),
]

# Number of steps per revolution
steps_per_revolution = 512  # Adjust based on your motor specifications

# Function to run the loop in the background
def background_loop(stop_flagM,speed):
    speeds = [0.05,0.01,0.005]
    try:
        while not stop_flagM.value:
            for _ in range(steps_per_revolution):
                for step in step_sequence:
                    if stop_flagM.value:  # Check if the loop should stop
                        break
                    set_step(*step)  # Activate the sequence
                    time.sleep(speeds[int(speed)-1])  # Delay between steps (adjust for speed)
                if stop_flagM.value:
                    break
    finally:
        # Turn off the motor at the end
        set_step(GPIO.LOW, GPIO.LOW, GPIO.LOW, GPIO.LOW)



# Function to start the motor
def start_motor(speed):
    if not stop_flagM.value :
        stop_motor()
        time.sleep(1)
    global process
    stop_flagM.value = False
    process = Process(target=background_loop, args=(stop_flagM,speed,))
    process.start()
    return f"The motor has started with a speed of level {speed}."

# Function to stop the motor
def stop_motor(input=""):
    if stop_flagM.value:  # Check if the motor is already stopped
        return "The motor is already stopped."
    else:
        stop_flagM.value = True
        process.join()  # Wait for the process to terminate
        return "The motor has been stopped."

# Cleanup GPIO pins at the end
def cleanup():
    GPIO.cleanup()




on_fan_tool = Tool(
    name="Turn on the fan, it's a motor",
    func= start_motor,
description="Useful only when you're asked about turning on the fan motor and you can choose between three levels of speed, 1, 2 and 3, for default: you choose 2"
)
off_fan_tool = Tool(
    name="Turn off the fan, it's a motor",
    func= stop_motor,
    description="Useful only when you're asked about turning off the fan motor"
)


def waiting(t):
    time.sleep(int(t))
    return f"the waiting time of {t} seconds in passed"

waiting_tool = Tool(
    name="Waiting for a period of time",
    func= waiting,
    description="Useful only when you want to wait a period of time"
)



import adafruit_dht
import board
import time
dht_device = adafruit_dht.DHT11(board.D14) 
def get_temp_hum(input=""): 
    temperature = dht_device.temperature
    humidity = dht_device.humidity
    return f"Temperature: {temperature}eC and Humidite: {humidity}%"
temp_hum_tool = Tool(
    name="Get temperature and humidity",
    func= get_temp_hum,
    description="Useful only when you're asked about temperature or humidity in the room"
)




import subprocess
import cv2
from ultralytics import YOLO

# Importation du modele YOLO
model = YOLO('yolo11m.pt')  # Remplacez 'yolo11m.pt' par votre fichier modele si necessaire

def Object_detection(input=""):
    # Capture une image a l'aide de libcamera
    command = "sudo libcamera-still -o image.jpg"
    subprocess.run(command, shell=True)

    # Effectuer la detection d'objets
    results = model("image.jpg")
    detections = results[0].boxes  # Extraire les detections

    # Verification si aucune detection n'est faite
    if detections is None or len(detections.cls) == 0:
        return "No objects detected in the image."

    class_names = results[0].names  # Acceder aux noms des classes pour le modele
    labels = detections.cls  # ID des classes detectees
    confidences = detections.conf  # Scores de confiance pour chaque detection

    # Preparer les labels detectes
    ll = []
    for label in labels:
        ll.append(f"{class_names[int(label)]}")

    # Creer un dictionnaire pour compter les occurrences de chaque element
    counts = {item: ll.count(item) for item in set(ll)}

    # Generer la description des objets detectes
    description = []
    for item, count in counts.items():
        if count > 1:
            description.append(f"{count} of {item}s")
        else:
            description.append(item)

    # Joindre les descriptions et retourner le resultat
    r = " and ".join(description)
    return "There are in the image " + r

Object_detection_tool = Tool(
    name="Take a photo and detect object and persons",
    func= Object_detection,
    description="Useful only when you're asked to take a picture Take and detect object and persons, this is how you can see the environement"
)




from langchain.agents import initialize_agent


# Define tools for the agent
tools = [waiting_tool,Led3_fr_stop_tool ,Led3_fr_tool,Led2_fr_stop_tool ,Led2_fr_tool,Led1_fr_stop_tool ,Led1_fr_tool,on_fan_tool,off_fan_tool,on_light_tool1,on_light_tool2,on_light_tool3,off_light_tool1,off_light_tool2,off_light_tool3,light_states,search_tool,Weather_tool,Time_tool,temp_hum_tool,Object_detection_tool]

# Define memory
memory = ConversationBufferWindowMemory(
    memory_key='chat_history',
    k=10,
    return_messages=True
)

# Initialize the conversational agent
conversational_agent = initialize_agent(
    agent='chat-conversational-react-description',
    tools=tools,
    llm=llm,  # Replace LLM with our Groq-inference Llama
    verbose=True,
    max_iterations=10,
    early_stopping_method='generate',
    memory=memory
)

# system prompt
from langchain import OpenAI, ConversationChain
conversational_agent.agent.llm_chain.prompt.messages

fixed_prompt = '''You are a conversational and helpful assistant integrated into a smart home environment. you perfom all the tasks and follow the instruction without ignoring.

Your capabilities include:

Managing lighting in rooms one, two, and three (turn on/off and check states or control frequency of blinking, by using blinking light tool, the lights are on and bliking directly without verification).
Searching the internet for information.
taking pictures and detecting persons and objects
controlling and fun motor
getting information about weather in cities in the world
getting information about temperature and humiduty in the room 


Guidelines:
follow the instruction and wait for observation before taking the next action. you need to start by taking just the first needed action and waiting for observation for taking the next action and then do the same thing until finishing the tasks.
don't give a json response with more than one action in the same time, you need to give one json with one action and wait the excution and after observation take the next action.
don't give a repsonse if you don't see it in the observation and always take actions depend on the observation
don't give a final answer if you don't finish instruction in the input, you need to give an answer after finishing all the instructions. 
for each input asking, you can use one tool or action and after that you verify the observation and take the next tool or finale response to complete tasks, only observation that give you the real state of the system, you reason and take actions
for frequencies, you can use only integers in the input and you can calculate the frequency if needed
for tima waiting, you can use only integers and the input that you choose is on seconds ,for example the integer 3 means you will wait for 3 seconds.
each action return an observation, without observation you need to recall the action.
The frequency that you can use is between 0.1 and 60.

Remember, you are integrated into a smart home system and should respond in an intelligent, user-friendly, and conversational manner, providing the most accurate and efficient service and by taking all the actions needed. Confirm your actions at every step and offer to assist further if needed.
'''

conversational_agent.agent.llm_chain.prompt.messages[0].prompt.template = fixed_prompt

import socket
import struct  # Used for packing and unpacking message length

HOST = '0.0.0.0'  # Listen on all available interfaces
PORT = 20000      # Port number for communication

# Create a socket
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.bind((HOST, PORT))
server_socket.listen(1)

print("Waiting for connection...")
conn, addr = server_socket.accept()
print(f"Connected by {addr}")

def recv_full_message(connection):
    """ Receives a full message by first reading the length prefix. """
    try:
        # Read message length (first 4 bytes)
        raw_msg_len = connection.recv(4)
        if not raw_msg_len:
            return None

        # Unpack length (big-endian integer)
        msg_len = struct.unpack('>I', raw_msg_len)[0]

        # Receive the full message
        data = b""
        while len(data) < msg_len:
            packet = connection.recv(msg_len - len(data))
            if not packet:
                return None
            data += packet
        
        return data.decode("utf-8")
    except:
        return None

def send_message(connection, message):
    """ Sends a message with a length prefix. """
    encoded_message = message.encode("utf-8")
    message_length = struct.pack('>I', len(encoded_message))  # Pack length as 4-byte integer
    connection.sendall(message_length + encoded_message)  # Send length + message


import time

def retry_function(x, max_retries=3, timeout=60):
    for attempt in range(max_retries):
        start_time = time.time()
        try:
            result = conversational_agent(x)
            return result
        except Exception as e:
            print(f"Attempt {attempt + 1} failed: {e}")
        if time.time() - start_time > timeout:
            print("Timeout reached, retrying...")
        time.sleep(1)  
    raise Exception("Max retries reached, function failed.")

import pyaudio
import wave
import whisper

# Audio settings
FORMAT = pyaudio.paInt16  # 16-bit format
CHANNELS = 1  # Mono audio
RATE = 44100  # Sample rate in Hz
CHUNK = 1024  # Buffer size
RECORD_SECONDS = 10  # Duration of recording
OUTPUT_FILE = "recorded_audio.wav"







while True:
    try: 
        data = recv_full_message(conn)
        if (data == "record"):
            # Initialize PyAudio
            audio = pyaudio.PyAudio()

            # Open the microphone stream
            stream = audio.open(format=FORMAT, channels=CHANNELS,
                                rate=RATE, input=True,
                                frames_per_buffer=CHUNK)

            send_message(conn, "Recording...")
            frames = []

            # Record audio
            for _ in range(0, int(RATE / CHUNK * RECORD_SECONDS)):
                data = stream.read(CHUNK)
                frames.append(data)

            send_message(conn, "Recording finished")

            # Stop and close the stream
            stream.stop_stream()
            stream.close()
            audio.terminate()

            # Save the recorded audio
            with wave.open(OUTPUT_FILE, 'wb') as wf:
                wf.setnchannels(CHANNELS)
                wf.setsampwidth(audio.get_sample_size(FORMAT))
                wf.setframerate(RATE)
                wf.writeframes(b''.join(frames))

            print(f"Audio recorded and saved as {OUTPUT_FILE}")

            # Load Whisper model
            send_message(conn, "Transcribing audio...")
            model = whisper.load_model("tiny.en")  # You can change the model size
            result = model.transcribe(OUTPUT_FILE)
            response = conversational_agent(result["text"])
        else:
            response = retry_function(data)
        send_message(conn, response["output"])
    except KeyboardInterrupt:
        Turn_off_1()
        Turn_off_2()
        Turn_off_3()
        stats = [0,0,0]
        # Close connection
        conn.close()
        server_socket.close()
        break
